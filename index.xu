<style lang="less" src="./index.less"></style>
<template>
  <canvas 
    class="canvas custom-class" 
    canvas-id="shareCanvas" 
    wx:if="{{show}}" 
    style="width: {{container.width + 'px'}}; height: {{container.height + 'px'}};margin-left: {{container.left + 'px'}};margin-top: {{container.top + 'px'}};"></canvas>
</template>
<script>
  import wexp from 'wexp'

  export default class Draw extends wexp.component {
    config = {
      component: true
    }

    data = {
      show: false,
      container: {},
      nodes: [],
      resolve: '',
      reject: '',
      imageList: '',
      imageTemArr: [],
      ctx: ''
    }

    externalClasses = ['custom-class']

    properties = {}

    methods = {
      promisify(fn) {
        return function (args = {}) {
          return new Promise((resolve, reject) => {
            args.success = function (res) {
              resolve(res)
            }
            args.fail = function (res) {
              reject(res)
            }

            fn(args)
          })
        }
      },
      draw (options) {
        return new Promise((resolve, reject) => {
          this.setData({
            container: options.container,
            show: true,
            nodes: options.nodes,
            resolve: resolve,
            reject: reject
          }, () => {
            this.getImageList(options.nodes)
            this.loadAllImages()
          })
        })
      },
      getImageList (views) {
        const imageList = views.filter((r) => {
          return r.type === 'image'
        })
        this.setData({
          imageList
        })
      },
      loadAllImages () {
        const {imageList, imageTemArr, reject} = this.data
        for (let i = 0; i < imageList.length; i++) {
          ((i, self) => {
            self.getImageInfo(imageList[i].src).then(res => {
              imageTemArr.push(res)
              self.setData({
                imageTemArr
              }, () => {
                if (i === imageList.length - 1) {
                  self.startDraw()
                }
              })
            }).catch(res => {
              reject(res)
            })
          })(i, this)
        }
      },
      startDraw () {
        const {ctx, nodes, imageTemArr, container, resolve} = this.data
        for (let i = 0, imageIndex = 0; i < nodes.length; i++) {
          const r = nodes[i]
          switch (r.type) {
            case 'image':
              const imageHeight = r.height || imageTemArr[imageIndex].height * container.width / imageTemArr[imageIndex].width
              this.drawImage(imageTemArr[imageIndex].path, r.left, r.top, r.width, imageHeight, r.radius || 0)
              imageIndex++
              break
            case 'text':
              this.analysisText(r)
              break
            case 'rect':
              this.drawRect(r)
              break
          }
        }
        ctx.closePath()
        ctx.draw(false, () => {
          resolve()
        })
      },
      analysisText (params) {
        const {ctx} = this.data
        ctx.save()
        const {
          maxLine = 2,
          // breakWord = false,
          color = 'black',
          content = '',
          fontSize = 16,
          top = 0,
          left = 0,
          lineHeight = 20,
          textAlign = 'left',
          width,
          textDecoration = 'none'
        } = params
        const chr = content.split('')
        let temp = ''
        let row = []
        ctx.beginPath()
        ctx.setTextBaseline('top')
        ctx.setFontSize(fontSize)
        ctx.setFillStyle(color)
        ctx.setTextAlign(textAlign)
        for (let i = 0; i < chr.length; i++) {
          if (ctx.measureText) {
            temp += chr[i]
            const textWidth = ctx.measureText(temp).width
            if (textWidth > width) {
              i-- // 这里添加了a-- 是为了防止字符丢失，效果图中有对比
              const newRemp = temp.substring(0, temp.length - 1)
              row.push(newRemp)
              temp = ''
            }
          } else {
            wx.showToast({
              title: '微信版本太低，无法使用 measureText 功能',
              duration: 1000,
              mask: true,
              icon: 'none'
            })
          }
        }
        row.push(temp)

        // 如果数组长度大于最大行数 则截取前几个
        if (row.length > maxLine) {
          const rowCut = row.slice(0, maxLine)
          const rowPart = rowCut[maxLine - 1]
          let test = ''
          const empty = []
          for (let a = 0; a < rowPart.length; a++) {
            if (ctx.measureText) {
              if (ctx.measureText(test).width < width - fontSize * 2) {
                test += rowPart[a]
              } else {
                break
              }
            } else {
              wx.showToast({
                title: '微信版本太低，无法使用 measureText 功能',
                duration: 1000,
                mask: true,
                icon: 'none'
              })
            }
          }
          empty.push(test)
          const group = empty[0] + '...'
          rowCut.splice(maxLine - 1, 1, group)
          row = rowCut
        }
        for (let b = 0; b < row.length; b++) {
          this.drawText(row[b], left, top + b * lineHeight, width, fontSize, color, textAlign, textDecoration)
        }
        ctx.restore()
      },
      getImageInfo (url) {
        return new Promise((resolve, reject) => {
          wx.getImageInfo({
            src: url,
            complete: res => {
              if (res.errMsg === 'getImageInfo:ok') {
                resolve(res)
              } else {
                reject(new Error('getImageInfo fail'))
              }
            }
          })
        })
      },
      drawImage (path, left, top, width, height, radius) {
        const {ctx} = this.data
        ctx.save()
        if (radius) {
          this.drawCircle(left, top, width, height, radius)
        }
        ctx.drawImage(path, left, top, width, height)
        ctx.restore()
      },
      getRadius (radius) {
        if (typeof radius === 'number') {
          return new Array(4).fill(radius)
        } else if (typeof radius === 'string') {
          const arr = radius.split(',')
          if (arr.length === 2) {
            const newArr = []
            newArr[0] = newArr[2] = +arr[0]
            newArr[1] = newArr[3] = +arr[1]
            return newArr
          } else if (arr.length === 4) {
            const newArr = arr.map((r) => {
              return +r
            })
            return newArr
          }
        }
      },
      drawCircle (left, top, width, height, radius) {
        const {ctx} = this.data
        // const r = Math.sqrt(width ** 2 + height ** 2)
        const radiusArr = this.getRadius(radius)
        ctx.setFillStyle('transparent')
        ctx.arc(left + radiusArr[0], top + radiusArr[0], radiusArr[0], Math.PI, Math.PI * 1.5)
        ctx.moveTo(left + radiusArr[0], top)
        ctx.lineTo(left + width - radiusArr[0], top)
        ctx.lineTo(left + width, top + radiusArr[0])
        ctx.arc(left + width - radiusArr[1], top + radiusArr[1], radiusArr[1], Math.PI * 1.5, Math.PI * 2)
        ctx.lineTo(left + width, top + height - radiusArr[1])
        ctx.lineTo(left + width - radiusArr[1], top + height)
        ctx.arc(left + width - radiusArr[2], top + height - radiusArr[2], radiusArr[2], 0, Math.PI * 0.5)
        ctx.lineTo(left + radiusArr[2], top + height)
        ctx.lineTo(left, top + height - radiusArr[2])
        ctx.arc(left + radiusArr[3], top + height - radiusArr[3], radiusArr[3], Math.PI * 0.5, Math.PI)
        ctx.lineTo(left, top + radiusArr[3])
        ctx.lineTo(left + radiusArr[3], top)
        ctx.fill()
        ctx.closePath()
        ctx.clip()
      },
      drawText (text, left, top, width, fontSize, color, textAlign, textDecoration) {
        const {ctx} = this.data
        const rectWidth = ctx.measureText(text).width
        if (textDecoration === 'overline') {
          this.drawRect({background: color, top: top, left: left, width: rectWidth, height: 1})
        } else if (textDecoration === 'line-through') {
          this.drawRect({background: color, top: top + fontSize / 2 + 1, left: left, width: rectWidth, height: 1})
        } else if (textDecoration === 'underline') {
          this.drawRect({background: color, top: top + fontSize, left: left, width: rectWidth, height: 1})
        }
        ctx.fillText(text, left, top, rectWidth)
      },
      drawRect (params) {
        const {ctx} = this.data
        ctx.save()
        const {background, top = 0, left = 0, width = 0, height = 0, radius = 0} = params
        if (radius) {
          this.drawCircle(left, top, width, height, radius)
        }
        ctx.setFillStyle(background)
        ctx.fillRect(left, top, width, height)
        ctx.restore()
      },
      saveImage () {
        return new Promise((resolve, reject) => {
          wx.canvasToTempFilePath({
            canvasId: 'shareCanvas',
            complete: res => {
              if (res.errMsg === 'canvasToTempFilePath:ok') {
                resolve(res)
              } else {
                reject(res)
              }
            }
          }, this)
        })
      }
    }

    ready () {
      const ctx = wx.createCanvasContext('shareCanvas', this)
      this.setData({
        ctx: ctx
      })
    }
  }
</script>
